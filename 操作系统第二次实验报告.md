#操作系统第二次实验报告
###一、实验思考题


 >**Thinking 3.1** 将宏函数的函数体写成了do{...}while(0)的形式，而不是仅仅写成形如{...}的语句快，这样的写法好处是什么？   
 
* 辅助定义复杂的宏，避免引用的时候出错。  
比如我们定义宏时，这样定义：  
 
		#define 
		DOSOMETHING()  
		f1();  
		f2();  
	这是如果再调用时这样写： 
	 
		if(a>0)
    	DOSOMETHING();  
    因为宏在预处理的时候会直接被展开，实际上写的代码是这个样子的：  
    
    	if(a>0)
    	f1();
		f2();  
	这就出现了问题，因为**无论a是否大于零，f2都会被执行，与原意不符。**  
	而如果只加入{}括号的话，这时会变为： 
	  
		if(a]]>0)
		{
  	  		f1();
  	  		f2();
		};
	这样显然连编译都不能通过。所以我们使用do{...}while(0)语句，来划分完整的一个宏定义的函数。

>**Thinking 3.2** 了解了二级页表页目录自映射的原理之后，我们知道， Win2k 内核的虚存管理也是采用了二级页表的形式，其页表所占的 4M 空间对应的虚存起始地址为 0xC0000000，那么，它的页目录的起始地址是多少呢？

* 0xC0000000对应的是第0xC0000个页表项，则页目录相对二级页表的起始地址偏移0x000C0000*4 = 0x00300000。所以页目录起始为0xC0000000+0x00300000 = 0xC0300000。

>**Thinking 3.3** 思考一下 tlb_out 汇编函数，结合代码阐述一下跳转到 NOFOUND的流程？

* 从函数传递的数据中找到TLB地址，并判断是否找到该地址。如果没有找到，则跳转到NOFOUND。

###二、实验难点

本次试验主要编写了两部分内容，一个是对页表的操作，另一个是虚拟地址以及一级、二级页表地址之间的转化。  

**难点：** 
 
1. 对大量宏定义的理解。不过有了ctag之后，简便了许多。  
2. 理解页表的two－level结构，花费了很久。
3. 理解宏定义中的feild，以及代码中的pp_link。 
2. 地址转换如下图所示  
<img
src="https://github.com/yuanmengyang/Test/blob/master/地址转换.png?raw=true" width="300"/>

###三、体会与感想
在做实验的过程中，接触到的新的事物感到费解，尤其是很多实验无法知道自己的结果是否正确。在知道判断方法之后，经过尝试，实验就easy很多。

